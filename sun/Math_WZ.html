<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>GB sun JS</title>
</head>

<body>
	<div id="container">
		<div style="position: absolute; top:18px; left: 100px; height: 600px; background-color: transparent; width:250px;
	display: flex; flex-direction: column; gap: 10px;">

			<div style="display: flex; flex-direction: row;">最大生命 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value, 1)" id="I1"></div>
			<div style="display: flex; flex-direction: row;">生命成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,2)" id="I2"></div>
			<div style="display: flex; flex-direction: row;">初始生命 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,3)" id="I3"></div>
			<div style="display: flex; flex-direction: row;">最大法力 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,4)" id="I4"></div>
			<div style="display: flex; flex-direction: row;">法力成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,5)" id="I5"></div>
			<div style="display: flex; flex-direction: row;">初始法力 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,6)" id="I6"></div>
			<div style="display: flex; flex-direction: row;">最高物攻 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,7)" id="I7"></div>
			<div style="display: flex; flex-direction: row;">物攻成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,8)" id="I8"></div>
			<div style="display: flex; flex-direction: row;">初始物攻 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,9)" id="I9"></div>
			<div style="display: flex; flex-direction: row;">最大物防 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,10)" id="I10"></div>
			<div style="display: flex; flex-direction: row;">物防成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,11)" id="I11"></div>
			<div style="display: flex; flex-direction: row;">初始物防 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,12)" id="I12"></div>
			<div style="display: flex; flex-direction: row;">最大每5秒回血 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,13)" id="I13"></div>
			<div style="display: flex; flex-direction: row;">每5秒回血成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,14)" id="I14"></div>
			<div style="display: flex; flex-direction: row;">初始每5秒回血 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,15)" id="I15"></div>
			<div style="display: flex; flex-direction: row;">最大每5秒回蓝 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,16)" id="I16"></div>
			<div style="display: flex; flex-direction: row;">每5秒回蓝成长 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,17)" id="I17"></div>
			<div style="display: flex; flex-direction: row;">初始每5秒回蓝 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,18)" id="I18"></div>
			<div style="display: flex; flex-direction: row;">最大攻速 <input type="range" value="0" min="0" max="10000"
					step="0.01" oninput="changeValue(this.value,19)" id="I19"></div>
		</div>
	</div>


</body>

<style>
	body {
		margin: 0px;
		height: 100%;
		width: 100%;
		background-color: rgb(255, 255, 255);
	}

	#container {
		/* position: absolute; */
		width: 100%;
		/* height: 100%; */
		/* padding: auto; */
		background-color: rgb(255, 255, 255);
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
	}

	#container>canvas {
		/* width: 500px; */
		height: 100%;
		/* width: 100%; */
		/* height: 500px; */
	}
</style>

<script type="module">
	import * as SUN from './GBsun.js'

	let str = `7000	275	3150	0	0	0	347	13	165	392	21.14	96	92	3.143	48	0	0	0	14.00%
5483	179.6	2968	1808	97	450	330	11.5	169	358	18.57	98	80	2.214	49	38	1.571	16	42.00%
5655	190.5	2988	1704	91	430	386	15.29	172	323	16.5	92	75	2.143	45	36	1.5	15	42.00%
5968	192.8	3269	0	0	0	427	17.86	177	349	18.57	89	81	2.214	50	0	0	0	28.00%
6205	211.9	3239	1808	97	450	385	15.14	173	359	19.5	86	79	2.286	47	38	1.571	16	14.00%
6232	210	3292	1822	98	450	388	15.5	171	342	18.36	85	99	3.357	52	46	1.929	19	14.00%
6164	281.5	3105	100	0	100	289	9.786	152	361	19.5	88	77	2.357	44	0	0	0	0.00%
7176	292.4	3083	1722	93	420	328	10.5	181	475	26.64	102	100	3.5	51	37	1.571	15	28.00%
5471	167.6	3125	1946	104	490	309	10.86	157	295	14.57	91	70	1.857	44	41	1.714	17	0.00%
5037	155.5	2860	1988	107	490	297	8.857	173	348	18.07	95	64	1.714	40	43	1.786	18	14.00%
5584	181.6	3041	2002	108	490	296	9.357	165	330	17.36	87	71	2	43	44	1.857	18	14.00%
5824	185.4	3229	2016	109	490	293	8.786	170	326	17.14	86	74	2	46	44	1.857	18	14.00%
5583	171	3189	1946	104	490	292	9.5	159	323	16.5	92	71	1.857	45	41	1.714	17	14.00%
5399	174.4	2958	2002	108	490	317	10.64	168	342	16.86	106	69	1.929	42	44	1.857	18	14.00%
5429	167.6	3083	1960	105	490	296	9.357	165	305	15.29	91	70	1.857	44	41	1.714	17	14.00%
5655	180	3135	1988	107	490	287	9.357	156	330	17.36	87	72	2	44	43	1.786	18	14.00%
6014	198.5	3235	200	0	200	293	8.786	170	336	17.64	89	76	2.143	46	50	0	50	14.00%
5611	185.1	3019	1960	105	490	287	8.571	167	330	17.36	87	71	2	43	41	1.714	17	14.00%
5994	190.8	3323	1960	105	490	293	8.786	170	315	16.57	83	76	2.071	47	41	1.714	17	14.00%
5916	202	3088	1988	107	490	263	7.857	153	309	15.29	95	75	2.214	44	43	1.786	18	14.00%
5513	172.9	3093	1974	106	490	298	9.857	160	320	16.64	87	70	1.857	44	42	1.786	17	14.00%
5799	198	3027	1988	107	490	293	8.786	170	320	16.64	87	73	2.143	43	43	1.786	18	14.00%
6165	217.4	3122	1988	107	490	290	9.071	163	343	17.5	98	77	2.357	44	42	1.786	17	14.00%
6703	249.9	3205	2016	109	490	309	10.07	168	374	20.5	87	83	2.714	45	44	1.857	18	14.00%
6280	204.3	3420	1988	107	490	278	8.286	162	390	20.79	99	91	2.429	57	42	1.786	17	14.00%
8149	345.6	3311	1694	91	420	297	9.071	170	497	24.79	150	113	4.143	55	36	1.5	15	14.00%
6835	242.3	3443	1680	90	420	284	9.286	154	396	21.57	94	86	2.643	49	35	1.429	15	14.00%
6811	257.4	3208	1926	104	470	328	10.86	176	413	22.5	98	85	2.857	45	42	1.786	17	14.00%
5399	174.4	2958	1926	104	470	305	9.786	168	340	17.64	93	69	1.929	42	42	1.786	17	14.00%
7107	270.4	3322	1808	97	450	297	9.643	162	394	21.57	92	89	3	47	38	1.571	16	14.00%
5910	190.9	3238	1898	102	470	292	9.5	159	350	18.14	96	66	2	38	41	1.714	17	14.00%
5986	200.3	3182	1784	96	440	396	16.79	161	336	17.86	86	71	2.143	41	38	1.571	16	42.00%
5584	181.6	3041	200	0	200	362	13.36	175	344	18.07	91	75	2.071	46	50	0	50	28.00%
5989	184.9	3401	1756	94	440	400	16.14	174	323	16.79	88	69	1.929	42	36	1.5	15	42.00%
5725	194.1	3007	1770	95	440	396	16.79	161	340	18.07	87	66	2.071	37	37	1.571	15	28.00%
6014	198.5	3235	1756	94	440	411	17.07	172	346	18.36	89	69	2.071	40	36	1.5	15	42.00%
5898	194.6	3173	1784	96	440	403	16.5	172	319	16.29	91	68	2.071	39	38	1.571	16	42.00%
5710	176.3	3242	1770	95	440	376	14.79	169	338	17.36	95	66	1.857	40	37	1.571	15	42.00%
5669	192.3	2977	1770	95	440	407	17.29	165	329	17.5	84	63	1.929	36	38	1.571	16	42.00%
5799	198	3027	1742	93	440	394	15	184	329	16.79	94	66	2.071	37	36	1.5	15	42.00%
5611	185.1	3019	1784	96	440	410	15.86	188	329	16.79	94	68	2.071	39	38	1.571	16	28.00%
7350	288.8	3307	1746	94	430	321	11.57	159	397	21.14	101	98	3.357	51	37	1.571	15	28.00%
8341	329.4	3450	100	0	100	301	10.57	153	504	27.07	125	115	4.143	57	5	0	5	14.00%
8476	352.8	3537	1926	104	470	273	8.357	156	394	20.36	109	117	4.214	58	42	1.786	17	14.00%
8611	369.6	3437	0	0	0	316	11.07	161	504	27.07	125	119	4.429	57	0	0	0	28.00%
9328	412.1	3558	1708	92	420	286	8.786	163	514	27.29	132	128	4.929	59	36	1.5	15	14.00%
7669	319.1	3201	1926	104	470	286	8.786	163	360	18.64	99	106	3.786	53	42	1.786	17	14.00%
8638	366.3	3510	1666	89	420	288	9.286	158	430	22.14	120	119	4.357	58	34	1.429	14	14.00%
8073	336	3369	1940	105	470	302	10.29	158	504	27.07	125	117	4.214	58	42	1.786	17	42.00%
8581	372.6	3364	1694	91	420	295	8.357	178	459	22.86	139	118	4.429	56	36	1.5	15	14.00%
8057	380.1	3535	1694	91	420	306	10.64	157	494	26.5	123	121	4.5	58	36	1.5	15	14.00%
7000	275	3150	1760	95	430	318	11	164	409	22.07	100	92	3.143	48	37	1.571	15	14.00%
7344	270	3564	0	0	0	343	12.36	170	390	20.79	99	97	3.071	54	0	0	0	14.00%
8050	316.3	3622	0	0	0	346	13	164	400	21.57	98	106	3.643	55	0	0	0	14.00%
6264	243	2862	1732	93	430	327	11.79	162	418	22.29	106	83	2.786	44	36	1.5	15	28.00%
7107	270.4	3322	10	0	10	343	12.36	170	386	20.36	101	94	3.071	51	0	0	0	7.00%
6612	256.5	3021	1836	99	450	335	12.29	163	375	19.5	102	99	3.357	52	39	1.643	16	28.00%
5397	179.4	2886	100	0	100	362	14	166	349	18.79	86	72	2	44	0	0	0	28.00%
6732	247.5	3267	1760	95	430	380	14.79	173	394	22.14	84	89	2.786	50	37	1.571	15	28.00%
7420	291.5	3339	1694	91	420	325	11.36	166	428	23.57	98	98	3.357	51	36	1.5	15	28.00%
7140	280.5	3213	1694	91	420	355	13.14	171	415	22.86	95	98	3.357	51	36	1.5	15	42.00%
6585	235.1	3293	1760	95	430	349	13	167	385	20.79	94	87	2.643	50	37	1.571	15	14.00%
6900	262.5	3225	1742	93	440	363	14.29	163	381	19.14	113	79	2.786	40	36	1.5	15	28.00%
7473	286.1	3467	0	0	0	361	13.36	174	371	19.07	104	101	3.357	54	0	0	0	14.00%
7516	291.6	3434	1774	96	430	345	12.64	168	402	22.36	89	99	3.357	52	39	1.643	16	42.00%
6210	236.3	2902	0	0	0	330	12.36	157	391	20.36	106	85	2.714	47	0	0	0	14.00%
7155	270.4	3370	5	0	5	329	11.5	168	409	22.07	100	94	3.071	51	0	0	0	56.00%
7268	270.4	3483	1808	97	450	320	11.5	159	408	22.07	99	98	3.214	53	38	1.571	16	28.00%
6700	237.5	3375	1784	96	440	328	10.86	176	388	20.07	107	81	2.643	44	38	1.571	16	28.00%`

	let arr = str.split('\n')
	let data = arr.map((s) => {
		return s.split('\t').map((i, idx) => {
			let ans = parseFloat(i)
			switch (idx) {
				case 0: return ans / 10000;
				case 1: return ans / 1000;
				case 2: return ans / 10000;
				case 3: return ans / 10000;
				case 4: return ans / 100;
				case 5: return ans / 1000;
				case 6: return ans / 1000;
				case 7: return ans / 100;
				case 8: return ans / 1000;
				case 9: return ans / 1000;
				case 10: return ans / 100;
				case 11: return ans / 1000;
				case 12: return ans / 100;
				case 13: return ans / 10;
				case 14: return ans / 100;
				case 15: return ans / 100;
				case 16: return ans / 10;
				case 17: return ans / 100;
				case 18: return ans / 100;
			}
		})
	})
	console.log(data);

	let gameconsole = new SUN.sunConsole(600, 660, false, false)

	document.getElementById('container').appendChild(gameconsole.get_ConsoleDOM())

	const Font = SUN.Font.DEFAULT()

	const Color = {
		0: SUN.Color.PICO(0),
		1: SUN.Color.PICO(1),
		2: SUN.Color.PICO(2),
		3: SUN.Color.PICO(3),
		4: SUN.Color.PICO(4),
		5: SUN.Color.PICO(5),
		6: SUN.Color.PICO(6),
		7: SUN.Color.PICO(7),
		8: SUN.Color.PICO(8),
		9: SUN.Color.PICO(9),
		10: SUN.Color.PICO(10),
		11: SUN.Color.PICO(11),
		12: SUN.Color.PICO(12),
		13: SUN.Color.PICO(13),
		14: SUN.Color.PICO(14),
		15: SUN.Color.PICO(15)
	}

	const WHITE = SUN.Color.COLOR('white')
	const HIGHLIGHT = SUN.Color.PICO(10)
	const FUNCTION = SUN.Color.PICO(14)
	const TESTCOLOR = SUN.Color.RGB8(255, 255, 0, 20)

	class Formula {
		constructor(args) {

		}

		get_Size(scale = 1) {
			return new SUN.Vector2(0, 0)
		}

		get_Align(scale = 1) {
			return new SUN.Vector2(0, 0)
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			render.draw_Pixel(10, 10, color)
		}
	}

	class FM_Text extends Formula {
		constructor(args, color) {
			super()
			this.text = args
			this.color = color
		}

		get_Size(scale = 1) {
			let size = Font.get_StringRect(this.text).size
			size.x *= scale
			size.y *= scale
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			// let size = this.get_Size(scale)
			// render.draw_Rect(SUN.Rect.XYWH(Math.round(x), Math.round(y), size.x, size.y), TESTCOLOR)
			render.draw_String(x, y, this.text, Font, this.color || color)
		}
	}

	class FM_DIV extends Formula {
		constructor(args) {
			super()
			this.top = args[0]
			this.bottom = args[1]
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.x = Math.max(top.x, bottom.x) + 4
			size.y = top.y + bottom.y + 5
			return size
		}

		get_Align(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.y = top.y - bottom.y
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = new SUN.Vector2(0, 0)
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.x = Math.max(top.x, bottom.x) + 4
			size.y = top.y + bottom.y + 5
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), SUN.Color.RGB8(255, 0, 0, 20))
			this.top.draw(render, x + Math.round((size.x - top.x) / 2), y, color, scale)
			render.draw_Line_DDA(x, y + top.y + 2, x + size.x - 1, y + top.y + 2, color)
			this.bottom.draw(render, x + (size.x - bottom.x) / 2, y + top.y + 5, color, scale)
		}
	}

	class FM_BRACE extends Formula {
		constructor(args) {
			super()
			this.center = args
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let center = this.center.get_Size(scale)
			size.x = (center.x + 8) * scale
			size.y = (center.y + 2) * scale
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = new SUN.Vector2(0, 0)
			let center = this.center.get_Size(scale)
			size.x = center.x + 8
			size.y = center.y + 2
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), SUN.Color.RGB8(255, 0, 0, 20))
			this.center.draw(render, x + 4, y + 1, color, scale)
			render.draw_Line_DDA(x, y + 2, x, y + size.y - 3, color)
			render.draw_Line_DDA(x + size.x - 1, y + 2, x + size.x - 1, y + size.y - 3, color)
			render.draw_Pixel(x + 1, y + 1, color)
			render.draw_Pixel(x + 2, y, color)
			render.draw_Pixel(x + size.x - 2, y + 1, color)
			render.draw_Pixel(x + size.x - 3, y, color)
			render.draw_Pixel(x + 1, y + size.y - 2, color)
			render.draw_Pixel(x + 2, y + size.y - 1, color)
			render.draw_Pixel(x + size.x - 2, y + size.y - 2, color)
			render.draw_Pixel(x + size.x - 3, y + size.y - 1, color)
		}
	}

	class FM_List extends Formula {
		constructor(args, ypos = 1, split = 2) {
			super()
			let arr = [];
			args.forEach((i) => {
				if (i instanceof FM_List) {
					// console.log(i)
					arr = arr.concat(i.list)
				}
				else {
					arr.push(i)
				}
			})
			this.list = arr
			this.split = split
			this.ypos = ypos
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let maxaligny = 0
			let start = 0
			let end = 0
			this.list.forEach((f) => {
				let fsize = f.get_Size(scale)
				let align = f.get_Align(scale)
				if (align.y / 2 - fsize.y / 2 < start) {
					start = align.y / 2 - fsize.y / 2
				}
				if (align.y / 2 + fsize.y / 2 > end) {
					end = align.y / 2 + fsize.y / 2
				}
				size.x += fsize.x + this.split
			})
			if (this.list.length > 0) {
				size.x -= this.split
			}
			size.y = Math.round(end - start)
			return size
		}

		// get_Align(scale) {
		// 	let size = new SUN.Vector2();
		// 	let maxaligny = 0
		// 	this.list.forEach((f) => {
		// 		let align = f.get_Align(scale)
		// 		maxaligny = Math.min(maxaligny, align.y)
		// 	})
		// 	size.y = maxaligny;
		// 	return size;
		// }

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = this.get_Size(scale)
			{
				let start = 0
				let end = 0
				this.list.forEach((f) => {
					let fsize = f.get_Size(scale)
					let align = f.get_Align(scale)
					if (align.y / 2 - fsize.y / 2 < start) {
						start = align.y / 2 - fsize.y / 2
					}
					if (align.y / 2 + fsize.y / 2 > end) {
						end = align.y / 2 + fsize.y / 2
					}
					size.x += fsize.x + this.split
				})
				y -= Math.round(start + size.y / 2)
				// render.draw_Rect(SUN.Rect.XYWH(x, Math.round(y), size.x, size.y), TESTCOLOR)
			}
			let i = 0
			this.list.forEach((f) => {
				let fsize = f.get_Size(scale)
				let align = f.get_Align(scale)
				f.draw(render, x + i, Math.round((y + (size.y - fsize.y) / 2 + align.y / 2)), color, scale)
				i += this.split + fsize.x
			})
		}
	}

	class FM_SQR extends Formula {
		constructor(args) {
			super()
			this.top = args[1]
			this.bottom = args[0]
		}

		get_Size(scale = 1) {
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)
			if (this.top) {
				let top = this.top.get_Size(scale)
				if (top.y < bottom.y / 2)
					this.top.draw(render, x - top.x - 3, y, color, scale)
				else {
					this.top.draw(render, x - top.x - 3, y + bottom.y / 2 - top.y, color, scale)
				}
			}

			size.x = bottom.x + 2
			// size.y = top.y + bottom.y + 5
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), TESTCOLOR)
			render.draw_Line_DDA(x, y, x + size.x, y, color)
			render.draw_Line_DDA(x, y, x - 3, y + bottom.y + 3, color)
			render.draw_Line_DDA(x - 3, y + bottom.y + 3, x - 6, y + bottom.y - 3, color)
			this.bottom.draw(render, x + (size.x - bottom.x) / 2 + 1, y + 3, color, scale)
		}
	}

	class FM_POW extends Formula {
		constructor(args) {
			super()
			this.top = args[1]
			this.bottom = args[0]
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)

			let top = this.top.get_Size(scale)

			size.x = bottom.x + top.x + 1
			size.y = top.y + bottom.y
			return size
		}

		get_Align(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.y = -top.y + 1
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)

			let top = this.top.get_Size(scale)

			size.x = bottom.x + top.x + 1
			size.y = top.y + bottom.y
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), TESTCOLOR)
			this.bottom.draw(render, x, y + top.y, color, scale)
			this.top.draw(render, x + bottom.x + 1, y, color, scale)
		}
	}

	// let test = new FM_List([new FM_Text("F"), new FM_BRACE(new FM_Text('x')), new FM_Text('='), new FM_POW([new FM_List([new FM_Text('sin'), new FM_BRACE(new FM_Text('x'))]), new FM_Text('2')])])
	let test

	// let test = new FM_List([
	// 	new FM_POW([new FM_Text('w'), new FM_Text('1')]),
	// 	new FM_POW([new FM_Text('x'), new FM_Text('1')]),
	// 	new FM_Text('+'),
	// 	new FM_Text('w'),
	// 	new FM_Text('.'),
	// 	new FM_Text('x'),
	// 	new FM_Text('+'),
	// 	new FM_Text('w'),
	// 	new FM_Text('.'),
	// 	new FM_Text('x'),
	// 	new FM_Text('+'),
	// 	new FM_Text('b')
	// ])
	let uid = 0;

	class NeuralLink {
		constructor(a, b, w) {
			this.uid = uid++;
			this.from = a;
			this.to = b;
			this.w = w;
			this.dW = 0;
		}

		get_Value() {
			let val = this.from.get_Value();
			return this.w * val;
		}

		get_Function(once = false) {
			if (once) {
				return new FM_List([new FM_Text(this.from.name ? this.from.name : ('N' + this.from.uid), HIGHLIGHT), new FM_Text('*'), new FM_Text('W', SUN.Color.PICO(8))])
			}
			let val = this.from.get_Function();
			return new FM_List([val, new FM_Text('*'), new FM_Text('W', SUN.Color.PICO(8))]);
		}
	}

	const SIGMOID = {
		f: (x) => {
			return 1 / (1 + Math.exp(-x));
		},
		dF: (x) => {
			let sigmoid = 1 / (1 + Math.exp(-x));
			return sigmoid * (1 - sigmoid);
		},
		func: (x) => {
			return new FM_DIV([
				new FM_Text('1'),
				new FM_List([
					new FM_Text('1'),
					new FM_Text('+'),
					new FM_POW([
						new FM_Text('e'),
						new FM_List([new FM_Text('-'), new FM_BRACE(x)])
					])
				])
			])
		}
	}

	const RELU = {
		f: (x) => {
			return Math.max(0, x);
		},
		dF: (x) => {
			return x < 0 ? 0 : 1;
		},
		func: (x) => {
			return new FM_List([
				new FM_Text('max', FUNCTION),
				new FM_BRACE(new FM_List([
					new FM_Text('0,'),
					x
				]))
			])
		}
	}

	const TANH = {
		f: (x) => {
			return Math.tanh(x);
		},
		dF: (x) => {
			let e = Math.exp(x);
			let e1 = Math.exp(-x);
			return (e - e1) / (e + e1);
		},
		func: (x) => {
			return new FM_List([
				new FM_Text('tanh', FUNCTION),
				new FM_BRACE(x)
			])
		}
	}

	class Neuron {
		constructor(name = undefined, layer = 0, activefunc = RELU, bias = 1) {
			this.uid = uid++;
			this.name = name;
			this.layer = layer;
			this.activefunc = activefunc.f;
			this.dActiveFunc = activefunc.dF;
			this.b = bias;
			this.activefuncFunc = activefunc.func;
			this.fromlist = [];
			this.tolist = [];
			this.value = 0;
			this.pos = [0, 0];
			this.forwarded = false;
			this.loss = null;
			this.dB = 0;
		}

		has_LinkTo(n) {
			for (let i = 0; i < this.tolist.length; i++) {
				let l = this.tolist[i];
				if (l.b === n) return true;
			}
			return false;
		}

		link(n, w = Math.random() * 2 - 1) {
			if (this.has_LinkTo(n)) return;
			let l = new NeuralLink(this, n, w);
			this.tolist.push(l);
			n.fromlist.push(l);
		}

		get_Value() {
			if (this.forwarded) return this.value;
			// console.log(this.name, "calcu!!")
			if (this.layer === 0) {
				this.forwarded = true;
				return this.value;
			}
			else {
				let val = 0;
				this.fromlist.forEach((link) => {
					val += link.get_Value();
				})
				this.forwarded = true;
				return this.value = this.activefunc(val + this.b);
			}
		}

		get_Function(once = false) {
			if (this.fromlist.length === 0) {
				return new FM_Text(this.name ? this.name : ('N' + this.uid), HIGHLIGHT);
			}
			else {
				let val = [];
				this.fromlist.forEach((link, idx, arr) => {
					val.push(link.get_Function(once));
					val.push(new FM_Text('+'));
				})
				val.push(new FM_Text('B', SUN.Color.PICO(11)))
				return this.activefuncFunc(new FM_List(val));
			}
		}

		set_Value(val) {
			this.value = val;
		}
	}

	function forward(ns, input = {}) {
		ns.forEach((nl) => {
			nl.forEach((n) => {
				n.forwarded = false;
			})
		})
		if (ns[0]) {
			ns[0].forEach((n, i) => {
				if (input[n.name] !== undefined) {
					n.set_Value(input[n.name])
				}
			})
		}
		let out = {}
		ns[ns.length - 1].forEach((n) => {
			out[n.name] = n.get_Value();
		})
		return out;
	}

	class Optimizer {
		constructor() {

		}

		init(ns) {

		}

		next(ns) {

		}
	}

	class GradientDescent extends Optimizer {
		constructor(learning_rate = 0.001) {
			super();
			this.learning_rate = learning_rate;
			// this.a = a;
			// this.last = {};
		}

		next(ns) {
			ns.forEach((nl) => {
				nl.forEach((n) => {
					n.b -= n.dB * this.learning_rate;
					n.tolist.forEach((l) => {
						l.w -= l.dW * this.learning_rate;
					})
				})
			})
		}
	}

	class Momentum extends Optimizer {
		constructor(learning_rate = 0.001, a = 0.8) {
			super();
			this.learning_rate = learning_rate;
			this.a = a;
			this.last = {};
		}

		init(ns) {
			ns.forEach((nl) => {
				nl.forEach((n) => {
					this.last[n.uid] = 0;
					n.tolist.forEach((l) => {
						this.last[l.uid] = 0;
					})
				})
			})
			console.log(this)
		}

		next(ns) {
			ns.forEach((nl) => {
				nl.forEach((n) => {
					// console.log(n.dB)
					let dB = this.last[n.uid] * this.a + n.dB * this.learning_rate;
					// console.log(this.last[n.uid], this.a, n.dB, this.learning_rate)
					n.b -= dB;
					this.last[n.uid] = dB;
					n.tolist.forEach((l) => {
						let dW = this.last[l.uid] * this.a + l.dW * this.learning_rate;
						l.w -= dW;
						this.last[l.uid] = dW;
					})
				})
			})
		}
	}

	function backpropagation(ns, input = {}, wanted = {}, optimizer, loss, dloss) {
		if (!optimizer) throw new Error('Optimizer is not defined');
		// forward update the output // get output object

		let out = forward(ns, input);

		if (!loss) {
			// loss = (O1-A1)^2+(O2-A2)^2+...+(On-An)^2
			loss = (out, wanted) => {
				let l = 0;
				for (let key in out) {
					if (wanted[key] === undefined) throw new Error("no wanted val on " + key);
					l += (out[key] - wanted[key]) ** 2;
				}
				return l;
			}
			dloss = (out_n, wanted_n) => {
				return 2 * (out_n - wanted_n)
			}
		}

		// output layer adjust
		ns[ns.length - 1].forEach((n) => {
			let val = n.get_Value();
			let dLoss_N = dloss(n.get_Value(), wanted[n.name]);
			// ActiveFunc(Out) = ActiveFunc(h*w+h*w+...+h*w+b)
			let dN_B = n.dActiveFunc(val);
			n.loss = dLoss_N;
			n.dB = dLoss_N * dN_B;
			n.fromlist.forEach((l) => {
				let dN_W = n.dActiveFunc(val) * l.from.get_Value();
				l.dW = dLoss_N * dN_W;
				// console.log(l.from.name + "-" + l.to.name, 'dW', l.dW);
			})

			for (let i = ns.length - 2; i > 0; i--) {
				let layer = ns[i];
				layer.forEach((n) => {
					let val = n.get_Value();
					// dLoss_N1 N1 = ActiveFunc(N*W + ... + b)
					let dLoss_N = 0;
					n.tolist.forEach((l) => {
						let dLoss_N1 = l.to.loss;
						let dN1_N = l.to.dActiveFunc(l.to.get_Value()) * l.w;
						// console.log(n.name, dN1_N)
						dLoss_N += dLoss_N1 * dN1_N;
					})
					n.loss = dLoss_N;
					let dN_B = n.dActiveFunc(val);
					n.dB = dLoss_N * dN_B;
					n.fromlist.forEach((l) => {
						let dN_W = n.dActiveFunc(val) * l.from.get_Value();
						l.dW = dLoss_N * dN_W;
					})
				})
			}
		})

		// gradient descent
		optimizer.next(ns);

		return [out, loss(out, wanted)];
	}

	function draw_NN(x, y, j, i, r, render, ns, maxsize, title = true, b = true, w = true) {
		x += r
		y += r
		maxsize = (maxsize) * i + 2 * r
		let pos = {}
		ns.forEach((nl, h) => {
			let posx = x
			let thissize = r * 2 + (nl.length - 1) * i
			let posy = y + (maxsize - thissize) / 2
			nl.forEach((n, k) => {
				let tx = posx + h * j
				let ty = posy + k * i
				let str = (Math.round(n.value * 100) / 100).toString()
				let rect = SUN.DEFAULT_FONT.get_StringRect(str)
				// let radius = Math.max(r, Math.round((rect.size.x + 4) / 2))
				let radius = r
				// console.log(rect)
				// console.log(radius)
				render.draw_Circle(tx, ty, radius, WHITE)
				render.draw_String(Math.round(tx - rect.size.x / 2), Math.round(ty - rect.size.y / 2), str, SUN.DEFAULT_FONT)
				n.r = radius
				n.pos = [tx, ty]
			})
		})
		r++
		ns.forEach((nl) => {
			nl.forEach((n) => {
				r = n.r
				if (title) {
					let name = n.name ? n.name : 'N' + n.uid
					let rect2 = SUN.DEFAULT_FONT.get_StringRect(name)
					render.draw_String(Math.round(n.pos[0] - rect2.size.x / 2), Math.round(n.pos[1] - r - rect2.size.y - 3), name, SUN.DEFAULT_FONT, HIGHLIGHT)
				}
				if (n.layer !== 0) {
					name = (Math.round(n.b * 100) / 100).toString()
					let rect2 = SUN.DEFAULT_FONT.get_StringRect(name)
					if (b)
						render.draw_String(Math.round(n.pos[0] - rect2.size.x / 2), Math.round(n.pos[1] + r + 3), name, SUN.DEFAULT_FONT)
				}
				n.tolist.forEach((l) => {
					let percent = SUN.Fn.clamp(SUN.Fn.percent(-1, 1, l.w), 0, 1)
					let color = SUN.Color.RGB(1 - percent, percent, 0)
					let dir = (new SUN.Vector2(l.to.pos[0] - l.from.pos[0], l.to.pos[1] - l.from.pos[1])).normalize()
					render.draw_Line_DDA(l.from.pos[0] + dir.x * r, l.from.pos[1] + dir.y * r, l.to.pos[0] - dir.x * r, l.to.pos[1] - dir.y * r, color)
					if (w) {
						let str = (Math.round(l.w * 100) / 100).toString()
						let rect = SUN.DEFAULT_FONT.get_StringRect(str)
						let tx = (l.from.pos[0] + dir.x * r) * 2 + (l.to.pos[0] - dir.x * r)
						let ty = (l.from.pos[1] + dir.x * r) * 2 + (l.to.pos[1] - dir.x * r)
						render.draw_String(Math.round(tx / 3 - rect.size.x / 2), Math.round(ty / 3 - rect.size.y / 2), str, SUN.DEFAULT_FONT)
					}
				})
			})
		})
	}

	function get_NN(ns) {
		let layer = {};
		ns.forEach((n) => {
			if (layer[n.layer]) {
				layer[n.layer].push(n)
			}
			else
				layer[n.layer] = [n]
		})
		let layerarr = [];
		let maxsize = 0;
		for (let key in layer) {
			maxsize = Math.max(maxsize, (layer[key].length - 1))
			layerarr.push(layer[key])
		}
		layerarr.sort((a, b) => {
			return a[0].layer > b[0].layer ? 1 : 0
		})
		return [layerarr, maxsize]
	}

	let i1 = new Neuron('I1', 0);
	let i2 = new Neuron('I2', 0);
	let i3 = new Neuron('I3', 0);
	let i4 = new Neuron('I4', 0);
	let i5 = new Neuron('I5', 0);
	let i6 = new Neuron('I6', 0);
	let i7 = new Neuron('I7', 0);
	let i8 = new Neuron('I8', 0);
	let i9 = new Neuron('I9', 0);
	let i10 = new Neuron('I10', 0);
	let i11 = new Neuron('I11', 0);
	let i12 = new Neuron('I12', 0);
	let i13 = new Neuron('I13', 0);
	let i14 = new Neuron('I14', 0);
	let i15 = new Neuron('I15', 0);
	let i16 = new Neuron('I16', 0);
	let i17 = new Neuron('I17', 0);
	let i18 = new Neuron('I18', 0);
	let i19 = new Neuron('I19', 0);

	let h1 = new Neuron('H1', 1);
	let h2 = new Neuron('H2', 1);
	let h3 = new Neuron('H3', 1);
	let h4 = new Neuron('H4', 1);
	let h5 = new Neuron('H5', 1);
	let h6 = new Neuron('H6', 1);
	let h7 = new Neuron('H7', 1);
	let h8 = new Neuron('H8', 1);

	let h21 = new Neuron('H1', 2);
	let h22 = new Neuron('H2', 2);
	let h23 = new Neuron('H3', 2);
	let h24 = new Neuron('H4', 2);
	let h25 = new Neuron('H5', 2);
	let h26 = new Neuron('H6', 2);
	let h27 = new Neuron('H7', 2);
	let h28 = new Neuron('H8', 2);

	let o1 = new Neuron('Assassin', 3);
	let o2 = new Neuron('Wizard', 3);
	let o3 = new Neuron('Helper', 3);
	let o4 = new Neuron('Archer', 3);
	let o5 = new Neuron('Tank', 3);
	let o6 = new Neuron('Warrior', 3);
	let [ns, maxsize] = get_NN([i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, h1, h2, h3, h4, h5, h6, h7, h8, o1, o2, o3, o4, o5, o6, h21, h22, h23, h24, h25, h26, h27, h28]);
	let gd = new Momentum(0.0001, 0.4);

	let i = [i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19]
	let h = [h1, h2, h3, h4, h5, h6, h7, h8]
	let h_2 = [h21, h22, h23, h24, h25, h26, h27, h28]
	let o = [o1, o2, o3, o4, o5, o6]

	i.forEach(i => {
		h.forEach(h => {
			i.link(h, Math.random())
		})
	})

	h.forEach(i => {
		h_2.forEach(h => {
			i.link(h, Math.random())
		})
	})

	h_2.forEach(i => {
		o.forEach(h => {
			i.link(h, Math.random())
		})
	})

	gd.init(ns);

	gameconsole.init = (sc) => {
		draw_NN(200, 20, 80, 30, 8, sc.Renderer, ns, maxsize, true, false, false)
		let len = lossarr1.length
		let w = sc.Renderer.size.x
		sc.Renderer.draw_Line_DDA(0, 610, w, 610, TESTCOLOR)
		sc.Renderer.draw_String(4, 600, 'loss >= 0.4', Font, TESTCOLOR)
		sc.Renderer.draw_Line_DDA(0, 650, w, 650, TESTCOLOR)
		sc.Renderer.draw_String(4, 640, 'loss = 0', Font, TESTCOLOR)
	}

	gameconsole.action = (sc, delta) => {
		if (sc.Keyboard.keymap[' '] && sc.Keyboard.keymap[' '].once) {
			train = !train
		}
	}

	let train = false
	let lossarr1 = [];

	function get_Input(idx) {
		let d = data[idx];
		return {
			I1: d[0],
			I2: d[1],
			I3: d[2],
			I4: d[3],
			I5: d[4],
			I6: d[5],
			I7: d[6],
			I8: d[7],
			I9: d[8],
			I10: d[9],
			I11: d[10],
			I12: d[11],
			I13: d[12],
			I14: d[13],
			I15: d[14],
			I16: d[15],
			I17: d[16],
			I18: d[17],
			I19: d[18]
		}
	}

	function get_Output(idx) {
		let ans = {
			Assassin: 0,
			Wizard: 0,
			Helper: 0,
			Archer: 0,
			Tank: 0,
			Warrior: 0
		}
		if (idx < 6) ans.Assassin = 1;
		else if (idx < 6 + 19) ans.Wizard = 1;
		else if (idx < 6 + 19 + 6) ans.Helper = 1;
		else if (idx < 6 + 19 + 6 + 10) ans.Archer = 1;
		else if (idx < 6 + 19 + 6 + 10 + 10) ans.Tank = 1;
		else { ans.Warrior = 1 };
		return ans;
	}
	let cases = 0;

	let pred =
	{
		I1: 0,
		I2: 0,
		I3: 0,
		I4: 0,
		I5: 0,
		I6: 0,
		I7: 0,
		I8: 0,
		I9: 0,
		I10: 0,
		I11: 0,
		I12: 0,
		I13: 0,
		I14: 0,
		I15: 0,
		I16: 0,
		I17: 0,
		I18: 0,
		I19: 0
	}

	const predscale =
	{
		I1: 10000,
		I2: 1000,
		I3: 10000,
		I4: 10000,
		I5: 100,
		I6: 1000,
		I7: 1000,
		I8: 100,
		I9: 1000,
		I10: 1000,
		I11: 100,
		I12: 1000,
		I13: 100,
		I14: 10,
		I15: 100,
		I16: 100,
		I17: 10,
		I18: 100,
		I19: 100
	}

	function getans(cases) {
		let max = -Infinity;
		let ans = "";
		for (let i in cases) {
			if (cases[i] > max) {
				max = cases[i]
				ans = i
			}
		}
		return ans
	}

	window.changeValue = function (value, idx) {
		pred['I' + idx] = parseFloat(value) / 10000
		console.log(pred)
		let ans = forward(ns, pred)
		// console.log(ans)
		res = getans(ans)
		console.log(res)
	}

	let res = "UNKNOWN"
	let target = "UNKNOWN"
	let count = 0
	let correct = 0

	gameconsole.render = (sc, delta) => {
		sc.Renderer.clear()
		let loss1
		if (train) {


			let inp
			for (let i = 0; i < 1000; i++) {
				cases = cases % data.length;
				inp = get_Input(cases)
				target = getans(get_Output(cases))
				let [ans, l] = backpropagation(ns, inp, get_Output(cases), gd)
				loss1 = l;
				res = ans;
				cases++;
				res = getans(res)
				count++
				if (res === target) correct++
			}


			// console.log(inp)
			for (let key in inp) {
				// console.log(key)
				pred[key] = inp[key]
				document.getElementById(key).value = inp[key] * 10000
			}
			// console.clear()


			console.log(loss1, target, res, target === res ? '💚' : '💔')
			console.log(Math.round(correct / count * 10000) / 100)
			lossarr1.push(SUN.Fn.clamp(loss1 * 100, 0, 40))
		}
		sc.Renderer.draw_String(510, 290, target, Font, SUN.Color.RGB(1, 1, 1))
		sc.Renderer.draw_String(510, 300, res, Font, target === res ? SUN.Color.RGB(0, 1, 0) : SUN.Color.RGB(1, 0, 0))
		draw_NN(200, 20, 80, 30, 8, sc.Renderer, ns, maxsize, true, false, false)
		let len = lossarr1.length
		let w = sc.Renderer.size.x
		sc.Renderer.draw_Line_DDA(0, 610, w, 610, TESTCOLOR)
		sc.Renderer.draw_String(4, 600, 'loss >= 0.4', Font, TESTCOLOR)
		sc.Renderer.draw_Line_DDA(0, 650, w, 650, TESTCOLOR)
		sc.Renderer.draw_String(4, 640, 'loss = 0', Font, TESTCOLOR)
		for (let i = 1; i < len; i++) {
			if (lossarr1[i - 1] % 200 === 0) {
				sc.Renderer.draw_String((i - 1) * w / (len - 1), 274, (lossarr1[i - 1]).toString(), Font, TESTCOLOR)
				// sc.Renderer.draw_Line_DDA((i - 1) * w / (len - 1), 231, (i - 1) * w / (len - 1), 269, TESTCOLOR)
			}
			sc.Renderer.draw_Line_DDA((i - 1) * w / (len - 1), 650 - lossarr1[i - 1], (i) * w / (len - 1), 650 - lossarr1[i], SUN.Color.RGB(1, 1, 1))
		}
		if (lossarr1.length > 200) {
			lossarr1.shift();
		}


	}

	gameconsole.run()
</script>

</html>