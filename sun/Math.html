<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>GB sun JS</title>
</head>

<body>
	<div id="container">
	</div>
	<input type="range" min="-10" max="10" step="0.1" oninput="changeValue1(this.value)">
	<input type="range" min="-10" max="10" step="0.1" oninput="changeValue2(this.value)">
	<input type="range" min="-10" max="10" step="0.1" oninput="changeValue3(this.value)">
</body>

<style>
	body {
		margin: 0px;
		height: 100%;
		width: 100%;
		background-color: black;
	}

	#container {
		width: 100%;
		/* height: 100%; */
		/* padding: auto; */
		background-color: rgb(0, 0, 0);
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
	}

	#container>canvas {
		/* width: 500px; */
		height: 100%;
		/* width: 100%; */
		/* height: 500px; */
	}
</style>

<script type="module">
	import * as SUN from './GBsun.js'

	window.changeValue1 = function (val) {
		i1.set_Value(val)
		o.get_Value()
	}
	window.changeValue2 = function (val) {
		i2.set_Value(val)
		o.get_Value()
	}
	window.changeValue3 = function (val) {
		i3.set_Value(val)
		o.get_Value()
	}

	let gameconsole = new SUN.sunConsole(480, 256, true)

	document.getElementById('container').appendChild(gameconsole.get_ConsoleDOM())

	const Font = SUN.Font.DEFAULT()

	const Color = {
		0: SUN.Color.PICO(0),
		1: SUN.Color.PICO(1),
		2: SUN.Color.PICO(2),
		3: SUN.Color.PICO(3),
		4: SUN.Color.PICO(4),
		5: SUN.Color.PICO(5),
		6: SUN.Color.PICO(6),
		7: SUN.Color.PICO(7),
		8: SUN.Color.PICO(8),
		9: SUN.Color.PICO(9),
		10: SUN.Color.PICO(10),
		11: SUN.Color.PICO(11),
		12: SUN.Color.PICO(12),
		13: SUN.Color.PICO(13),
		14: SUN.Color.PICO(14),
		15: SUN.Color.PICO(15)
	}

	const WHITE = SUN.Color.COLOR('white')
	const HIGHLIGHT = SUN.Color.PICO(10)
	const TESTCOLOR = SUN.Color.RGB8(255, 255, 0, 20)

	class Formula {
		constructor(args) {

		}

		get_Size(scale = 1) {
			return new SUN.Vector2(0, 0)
		}

		get_Align(scale = 1) {
			return new SUN.Vector2(0, 0)
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			render.draw_Pixel(10, 10, color)
		}
	}

	class FM_Text extends Formula {
		constructor(args, color) {
			super()
			this.text = args
			this.color = color
		}

		get_Size(scale = 1) {
			let size = Font.get_StringRect(this.text).size
			size.x *= scale
			size.y *= scale
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			// let size = this.get_Size(scale)
			// render.draw_Rect(SUN.Rect.XYWH(Math.round(x), Math.round(y), size.x, size.y), TESTCOLOR)
			render.draw_String(x, y, this.text, Font, this.color || color)
		}
	}

	class FM_DIV extends Formula {
		constructor(args) {
			super()
			this.top = args[0]
			this.bottom = args[1]
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.x = Math.max(top.x, bottom.x) + 4
			size.y = top.y + bottom.y + 5
			return size
		}

		get_Align(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.y = top.y - bottom.y
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = new SUN.Vector2(0, 0)
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.x = Math.max(top.x, bottom.x) + 4
			size.y = top.y + bottom.y + 5
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), SUN.Color.RGB8(255, 0, 0, 20))
			this.top.draw(render, x + Math.round((size.x - top.x) / 2), y, color, scale)
			render.draw_Line_DDA(x, y + top.y + 2, x + size.x - 1, y + top.y + 2, color)
			this.bottom.draw(render, x + (size.x - bottom.x) / 2, y + top.y + 5, color, scale)
		}
	}

	class FM_BRACE extends Formula {
		constructor(args) {
			super()
			this.center = args
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let center = this.center.get_Size(scale)
			size.x = (center.x + 8) * scale
			size.y = (center.y + 2) * scale
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = new SUN.Vector2(0, 0)
			let center = this.center.get_Size(scale)
			size.x = center.x + 8
			size.y = center.y + 2
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), TESTCOLOR)
			this.center.draw(render, x + 4, y + 1, color, scale)
			render.draw_Line_DDA(x, y + 2, x, y + size.y - 3, color)
			render.draw_Line_DDA(x + size.x - 1, y + 2, x + size.x - 1, y + size.y - 3, color)
			render.draw_Pixel(x + 1, y + 1, color)
			render.draw_Pixel(x + 2, y, color)
			render.draw_Pixel(x + size.x - 2, y + 1, color)
			render.draw_Pixel(x + size.x - 3, y, color)
			render.draw_Pixel(x + 1, y + size.y - 2, color)
			render.draw_Pixel(x + 2, y + size.y - 1, color)
			render.draw_Pixel(x + size.x - 2, y + size.y - 2, color)
			render.draw_Pixel(x + size.x - 3, y + size.y - 1, color)
		}
	}

	class FM_List extends Formula {
		constructor(args, ypos = 1, split = 2) {
			super()
			let arr = [];
			args.forEach((i) => {
				if (i instanceof FM_List) {
					// console.log(i)
					arr = arr.concat(i.list)
				}
				else {
					arr.push(i)
				}
			})
			this.list = arr
			this.split = split
			this.ypos = ypos
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			this.list.forEach((f) => {
				let fsize = f.get_Size(scale)
				size.y = Math.max(size.y, fsize.y)
				size.x += fsize.x + this.split
			})
			if (this.list.length > 0) {
				size.x -= this.split
			}
			// if (this.ypos === 1) {
			// 	let maxaligny = 0
			// 	this.list.forEach((f) => {
			// 		let align = f.get_Align(scale)
			// 		maxaligny = Math.min(maxaligny, align.y)
			// 	})
			// 	size.y += maxaligny / 2
			// }
			return size
		}

		// get_Align(scale) {
		// 	let size = new SUN.Vector2();
		// 	let maxaligny = 0
		// 	this.list.forEach((f) => {
		// 		let align = f.get_Align(scale)
		// 		maxaligny = Math.min(maxaligny, align.y)
		// 	})
		// 	size.y = maxaligny;
		// 	return size;
		// }

		draw(render, x, y, color = WHITE, scale = 1) {
			x = Math.round(x)
			y = Math.round(y)
			let size = this.get_Size(scale)
			if (this.ypos === 1) {
				let maxaligny = 0
				this.list.forEach((f) => {
					let align = f.get_Align(scale)
					maxaligny = Math.min(maxaligny, align.y)
				})
				y += Math.round(maxaligny / 2)
				// render.draw_Rect(SUN.Rect.XYWH(x, y - Math.round(maxaligny / 2), size.x, size.y), TESTCOLOR)
			}
			let i = 0
			this.list.forEach((f) => {
				let fsize = f.get_Size(scale)
				let align = f.get_Align(scale)
				f.draw(render, x + i, (this.ypos === 0 ? y : ((this.ypos === 2) ? (y + size.y - fsize.y) : Math.round((y + (size.y - fsize.y) / 2))) - (this.ypos === 1 ? Math.round(align.y / 2) : 0)), color, scale)
				i += this.split + fsize.x
			})
		}
	}

	class FM_SQR extends Formula {
		constructor(args) {
			super()
			this.top = args[1]
			this.bottom = args[0]
		}

		get_Size(scale = 1) {
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)
			if (this.top) {
				let top = this.top.get_Size(scale)
				if (top.y < bottom.y / 2)
					this.top.draw(render, x - top.x - 3, y, color, scale)
				else {
					this.top.draw(render, x - top.x - 3, y + bottom.y / 2 - top.y, color, scale)
				}
			}

			size.x = bottom.x + 2
			// size.y = top.y + bottom.y + 5
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), TESTCOLOR)
			render.draw_Line_DDA(x, y, x + size.x, y, color)
			render.draw_Line_DDA(x, y, x - 3, y + bottom.y + 3, color)
			render.draw_Line_DDA(x - 3, y + bottom.y + 3, x - 6, y + bottom.y - 3, color)
			this.bottom.draw(render, x + (size.x - bottom.x) / 2 + 1, y + 3, color, scale)
		}
	}

	class FM_POW extends Formula {
		constructor(args) {
			super()
			this.top = args[1]
			this.bottom = args[0]
		}

		get_Size(scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)

			let top = this.top.get_Size(scale)

			size.x = bottom.x + top.x + 1
			size.y = top.y + bottom.y
			return size
		}

		get_Align(scale = 1) {
			let size = new SUN.Vector2()
			let top = this.top.get_Size(scale)
			let bottom = this.bottom.get_Size(scale)
			size.y = top.y
			return size
		}

		draw(render, x, y, color = WHITE, scale = 1) {
			let size = new SUN.Vector2(0, 0)
			let bottom = this.bottom.get_Size(scale)

			let top = this.top.get_Size(scale)

			size.x = bottom.x + top.x + 1
			size.y = top.y + bottom.y
			// render.draw_Rect(SUN.Rect.XYWH(x, y, size.x, size.y), TESTCOLOR)
			this.bottom.draw(render, x, y + top.y, color, scale)
			this.top.draw(render, x + bottom.x + 1, y, color, scale)
		}
	}

	// let test = new FM_List([new FM_Text("F"), new FM_BRACE(new FM_Text('x')), new FM_Text('='), new FM_POW([new FM_List([new FM_Text('sin'), new FM_BRACE(new FM_Text('x'))]), new FM_Text('2')])])
	let test

	// let test = new FM_List([
	// 	new FM_POW([new FM_Text('w'), new FM_Text('1')]),
	// 	new FM_POW([new FM_Text('x'), new FM_Text('1')]),
	// 	new FM_Text('+'),
	// 	new FM_Text('w'),
	// 	new FM_Text('.'),
	// 	new FM_Text('x'),
	// 	new FM_Text('+'),
	// 	new FM_Text('w'),
	// 	new FM_Text('.'),
	// 	new FM_Text('x'),
	// 	new FM_Text('+'),
	// 	new FM_Text('b')
	// ])
	let uid = 0;

	class NeuralLink {
		constructor(a, b, w) {
			this.from = a;
			this.to = b;
			this.w = w;
		}

		get_Value() {
			let val = this.from.get_Value();
			return this.w * val;
		}

		get_Function(once = false) {
			if (once) {
				return new FM_List([new FM_Text(this.from.name ? this.from.name : ('N' + this.from.uid), HIGHLIGHT), new FM_Text('*'), new FM_Text('W', SUN.Color.PICO(8))])
			}
			let val = this.from.get_Function();
			return new FM_List([val, new FM_Text('*'), new FM_Text('W', SUN.Color.PICO(8))]);
		}
	}

	class Neuron {
		constructor(name = undefined, layer = 0, bias = 0, activefunc = (x) => {
			return 1 / (1 + Math.exp(-x));
		}, activefuncFunc = (x) => {
			// return new FM_List([
			// 	new FM_Text('Sigmoid'),
			// 	new FM_BRACE(x),
			// ])
			return new FM_DIV([
				new FM_Text('1'),
				new FM_List([
					new FM_Text('1'),
					new FM_Text('+'),
					new FM_POW([
						new FM_Text('e'),
						new FM_List([new FM_Text('-'), new FM_BRACE(x)])
					])
				], 2)
			])
		}) {
			this.uid = uid++;
			this.name = name;
			this.layer = layer;
			this.activefunc = activefunc;
			this.b = bias;
			this.activefuncFunc = activefuncFunc;
			this.fromlist = [];
			this.tolist = [];
			this.value = 0;
		}

		has_LinkTo(n) {
			for (let i = 0; i < this.tolist.length; i++) {
				let l = this.tolist[i];
				if (l.b === n) return true;
			}
			return false;
		}

		link(n, w = Math.random() * 20 - 10) {
			if (this.has_LinkTo(n)) return;
			let l = new NeuralLink(this, n, w);
			this.tolist.push(l);
			n.fromlist.push(l);
		}

		get_Value() {
			if (this.fromlist.length === 0) {
				return this.value;
			}
			else {
				let val = 0;
				this.fromlist.forEach((link) => {
					val += link.get_Value();
				})
				return this.value = this.activefunc(val);
			}
		}

		get_Function(once = false) {
			if (this.fromlist.length === 0) {
				return new FM_Text(this.name ? this.name : ('N' + this.uid), HIGHLIGHT);
			}
			else {
				let val = [];
				this.fromlist.forEach((link, idx, arr) => {
					val.push(link.get_Function(once));
					val.push(new FM_Text('+'));
				})
				val.push(new FM_Text('B', SUN.Color.PICO(11)))
				return this.activefuncFunc(new FM_List(val));
			}
		}

		set_Value(val) {
			this.value = val;
		}
	}

	function draw_NN(x, y, j, i, r, render, ns) {
		let layer = {};
		x += r
		y += r
		ns.forEach((n) => {
			if (layer[n.layer]) {
				layer[n.layer].push(n)
			}
			else
				layer[n.layer] = [n]
		})
		let layerarr = [];
		let maxsize = 0;
		for (let key in layer) {
			maxsize = Math.max(maxsize, r * 2 + (layer[key].length - 1) * j)
			layerarr.push(layer[key])
		}
		// console.log(layerarr)
		layerarr.sort((a, b) => {
			return a[0].layer > b[0].layer ? 1 : 0
		})
		// console.log(layerarr)
		let pos = {}
		layerarr.forEach((nl, h) => {
			let posx = x
			let thissize = r * 2 + (nl.length - 1) * j
			let posy = y + (maxsize - thissize) / 2
			nl.forEach((n, k) => {
				let tx = posx + h * j
				let ty = posy + k * i
				let str = (Math.round(n.value * 100) / 100).toString()
				let rect = SUN.DEFAULT_FONT.get_StringRect(str)

				// console.log(rect)
				render.draw_Circle(tx, ty, r, WHITE)
				render.draw_String(Math.round(tx - rect.size.x / 2), Math.round(ty - rect.size.y / 2), str, SUN.DEFAULT_FONT)

				n.pos = [tx, ty]
			})
		})
		r++
		ns.forEach((n) => {
			let name = n.name ? n.name : 'N' + n.uid
			let rect2 = SUN.DEFAULT_FONT.get_StringRect(name)
			render.draw_String(Math.round(n.pos[0] - rect2.size.x / 2), Math.round(n.pos[1] - r - rect2.size.y - 3), name, SUN.DEFAULT_FONT, HIGHLIGHT)
			n.tolist.forEach((l) => {
				let percent = SUN.Fn.clamp(SUN.Fn.percent(-10, 10, l.w), 0, 1)
				let color = SUN.Color.RGB(percent, 1 - percent, 0)
				let dir = (new SUN.Vector2(l.to.pos[0] - l.from.pos[0], l.to.pos[1] - l.from.pos[1])).normalize()
				render.draw_Line_DDA(l.from.pos[0] + dir.x * r, l.from.pos[1] + dir.y * r, l.to.pos[0] - dir.x * r, l.to.pos[1] - dir.y * r, color)
			})
		})
	}

	let i1 = new Neuron('I1', 0);
	let i2 = new Neuron('I2', 0);
	let i3 = new Neuron('I3', 0);
	let h1 = new Neuron('H2,1', 1);
	let h2 = new Neuron('H2,2', 1);
	let h3 = new Neuron('H3,1', 2);
	let h4 = new Neuron('H3,2', 2);
	let o = new Neuron('Out', 3);
	let ns = [i1, i2, i3, h1, h2, h3, h4, o];

	i1.link(h1);
	i1.link(h2);
	i2.link(h1);
	i2.link(h2);
	i3.link(h1);
	i3.link(h2);
	h1.link(h3);
	h1.link(h4);
	h2.link(h3);
	h2.link(h4);
	h3.link(o);
	h4.link(o);
	i1.set_Value(3);
	i2.set_Value(5);

	console.log(o)

	console.log(o.get_Value())
	test = o.get_Function(true)

	console.log(test)


	gameconsole.init = (sc) => {
	}

	gameconsole.action = (sc, delta) => {
	}

	gameconsole.render = (sc, delta) => {
		test.draw(sc.Renderer, 5, 10, WHITE, 1)
		draw_NN(60, 60, 60, 60, 11, sc.Renderer, ns)
	}

	gameconsole.run()
</script>

</html>